# -*- coding: utf-8 -*-
"""ML_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/160O6yp5JudUHg1lamEVw7Z6IwapD6GjX
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression, LogisticRegression
from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier, VotingClassifier
from sklearn.tree import DecisionTreeClassifier

from sklearn.metrics import mean_squared_error, r2_score
from sklearn.metrics import accuracy_score, classification_report
from sklearn.preprocessing import label_binarize
from sklearn.metrics import roc_curve, auc

file_path = "/content/NHANES-2017-2018-height-weight-with-gender.csv"
df = pd.read_csv(file_path)

df.head()

# Clean column names
df.columns  = df.columns.str.strip().str.lower()

# Clean gender values
df["gender"] = df["gender"].astype(str).str.strip().str.lower()

# Map gender safely
df["gender"] = df["gender"].map({
    "male": 0, "m": 0,
    "female": 1, "f": 1
})

# Fill missing numeric values with median
df["age"].fillna(df["age"].median(), inplace=True)
df["height"].fillna(df["height"].median(), inplace=True)
df["weight"].fillna(df["weight"].median(), inplace=True)

# Fill missing gender with mode
df["gender"].fillna(df["gender"].mode()[0], inplace=True)

df["bmi"] = df["weight"] / ((df["height"] / 100) ** 2)

def bmi_category(bmi):
    if bmi < 18.5:
        return "Underweight"
    elif bmi < 25:
        return "Normal"
    elif bmi < 30:
        return "Overweight"
    else:
        return "Obese"

df["bmi_category"] = df["bmi"].apply(bmi_category)

corr = df[["age", "height", "weight", "gender", "bmi"]].corr()

plt.figure()
plt.imshow(corr)
plt.colorbar()
plt.xticks(range(len(corr.columns)), corr.columns, rotation=45)
plt.yticks(range(len(corr.columns)), corr.columns)
plt.title("Feature Correlation Matrix")
plt.show()

features = ["age", "height", "weight", "bmi"]

for col in features:
    plt.figure()
    plt.hist(df[col], bins=30)
    plt.title(f"Distribution of {col}")
    plt.xlabel(col)
    plt.ylabel("Frequency")
    plt.show()

X = df[["age", "height", "weight", "gender"]]
y_bmi = df["bmi"]
y_cat = df["bmi_category"]

X_train, X_test, y_train, y_test = train_test_split(
    X, y_bmi, test_size=0.2, random_state=42
)

lr = LinearRegression()
lr.fit(X_train, y_train)

y_pred_lr = lr.predict(X_test)

print("Linear Regression Performance")
print("RMSE:", np.sqrt(mean_squared_error(y_test, y_pred_lr)))
print("R2 Score:", r2_score(y_test, y_pred_lr))

rf = RandomForestRegressor(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)

y_pred_rf = rf.predict(X_test)

print("Random Forest Performance")
print("RMSE:", np.sqrt(mean_squared_error(y_test, y_pred_rf)))
print("R2 Score:", r2_score(y_test, y_pred_rf))

df["predicted_bmi_lr"] = lr.predict(X)
df["predicted_bmi_rf"] = rf.predict(X)

log_reg = LogisticRegression(max_iter=1000)
log_reg.fit(X, y_cat)

df["predicted_bmi_category"] = log_reg.predict(X)

print("Logistic Regression Accuracy:",
      accuracy_score(y_cat, df["predicted_bmi_category"]))

print(classification_report(y_cat, df["predicted_bmi_category"]))

classes = sorted(y_cat.unique())
y_bin = label_binarize(y_cat, classes=classes)
y_score = log_reg.predict_proba(X)

plt.figure()
for i in range(len(classes)):
    fpr, tpr, _ = roc_curve(y_bin[:, i], y_score[:, i])
    roc_auc = auc(fpr, tpr)
    plt.plot(fpr, tpr, label=f"{classes[i]} (AUC={roc_auc:.2f})")

plt.plot([0, 1], [0, 1], linestyle="--")
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("ROC Curve for BMI Classification")
plt.legend()
plt.show()

lr_clf = LogisticRegression(max_iter=1000)
dt_clf = DecisionTreeClassifier(random_state=42)
rf_clf = RandomForestClassifier(n_estimators=100, random_state=42)

ensemble = VotingClassifier(
    estimators=[
        ("lr", lr_clf),
        ("dt", dt_clf),
        ("rf", rf_clf)
    ],
    voting="soft"
)

ensemble.fit(X, y_cat)

df["ensemble_bmi_category"] = ensemble.predict(X)

print("Ensemble Model Accuracy:",
      accuracy_score(y_cat, df["ensemble_bmi_category"]))

df.to_csv("/content/final_bmi_project_output.csv", index=False)
print("Final file saved: final_bmi_project_output.csv")